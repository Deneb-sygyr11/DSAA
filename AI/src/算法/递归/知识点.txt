定义：在计算机科学中，递归是一种解决计算问题的方法，其中解决方法取决于同一类问题的更小子集

说明：
    1、自己调用自己，如果说每个函数对应一种解决方案，自己调用自己意味着解决方案是一样的(有规律的)
    2、每次调用，函数处理的数据规模会较上次缩减，而且最后会缩减至无需继续递归
    3、内层函数调用完成，外层函数才算调用完成

深入到最里层称为“递”，由最里层出来称为“归”
在“递”的过程中，外层函数的局部变量(以及方法参数)并未消失，在“归”的时候仍能用到

斐波那契数列
    ·若一个递归函数只包含一个自身调用，则称之为单路递归
    ·若递归函数中包含多个自身调用，则称之为多路递归

    斐波那契数列是一个典型的多路递归的例子

斐波那契数列运算时方法的调用次数随 n 的增加也是一个类斐波那契数列，其中运算 f(n) 的总调用次数为 2*f(n+1)-1
    --自己的想法：当求解 f(n) 时，需先求解 f(n-1) 和 f(n-2) ，那么求解 f(n) 的调用次数即为 f(n-1) 的调用次数与 f(n-2) 的调用次数之和+1
                非常类似于斐波那契数列

斐波那契时间复杂度：
    由前知：求解 f(n) 的总调用次数为 2*f(n+1)-1
    又由数学推导可知：f(n) 的通项公式为 (1/(sqar(5)))*(((1+sqar(5))/2)^n-((1-sqar(5))/2)^n)  ps:找不到根号符。。。sqar就是开根
                                                                                           的意思
    简化得：f(n) = (1.618^n - (-0.618)^n)/2.236
    代入递归公式可得：2*(1.618^(n+1) - (-0.618)^(n+1))/2.236 - 1
    所以时间复杂度 O(n) 为： 1.618^n

    使用记忆法优化后时间复杂度 O(n) 为 n

爆栈问题：
    尾调用：如果函数最后一步是调用一个函数，则为 尾调用
        e.g.
        f a(){
            return b();
        } #尾调用

        f a(){
            int c = b();
            return c;
        } #非尾调用

        f a(){
            return b() + 1;
        } #非尾调用

    尾调用的意义：部分语言能对尾调用的函数做优化(目前就c++和scala...)，同理能使递归进行优化   @:emmm...这里是java欸，有用吗，没有用。

    解决爆栈问题的根本方法：将递归代码改为循环代码     @:解决不了问题，就解决方法 =) (就解决你啊（小明音）)
    理论上所有递归代码都能改成循环代码

递归时间复杂度计算：
    master theorem (主定理):
        若有递归式 T(n) = aT(n/b)+f(n)，其中:
            ·T(n)为问题的运行时间，n为数据规模
            ·a为子问题个数
            ·T(n/b)是子问题运行时间，每个子问题被拆解为原问题数据规模的n/b   p.s.所以每次缩小的规模都要成相同的比例
            ·f(n)是除递归为进行的运算
        令 b^x = a:
            则 T(n) =
                · θ(n^x), f(n) = O(n^c) && c < x
                · θ((n^x)*log(n)) ,f(n) = θ(n^x)
                · θ(n^c), f(n) = Ω(n^c) && c > x

    展开求解:
        e.g.
            递归求和:
                long sum(long n){
                    if(n == 1){
                        return 1;
                    }
                    return n + sum(n-1);
                }
            在该段代码中：
                T(n) = T(n-1) + c, T(1) = c
                推出 T(n) = nc
                时间复杂度为O(n)

        @:展开求解这玩意儿，就具体情况具体分析呗


